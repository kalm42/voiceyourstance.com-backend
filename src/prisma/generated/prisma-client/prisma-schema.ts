// Code generated by Prisma (prisma@1.34.10). DO NOT EDIT.
  // Please don't change this file manually but run `prisma generate` to update it.
  // For more information, please read the docs: https://www.prisma.io/docs/prisma-client/

export const typeDefs = /* GraphQL */ `type Address {
  id: ID!
  hash: String!
  name: String!
  line1: String!
  line2: String
  city: String!
  state: String!
  zip: String!
  createdAt: DateTime!
  updatedAt: DateTime!
}

type AddressConnection {
  pageInfo: PageInfo!
  edges: [AddressEdge]!
  aggregate: AggregateAddress!
}

input AddressCreateInput {
  id: ID
  hash: String!
  name: String!
  line1: String!
  line2: String
  city: String!
  state: String!
  zip: String!
}

input AddressCreateOneInput {
  create: AddressCreateInput
  connect: AddressWhereUniqueInput
}

type AddressEdge {
  node: Address!
  cursor: String!
}

enum AddressOrderByInput {
  id_ASC
  id_DESC
  hash_ASC
  hash_DESC
  name_ASC
  name_DESC
  line1_ASC
  line1_DESC
  line2_ASC
  line2_DESC
  city_ASC
  city_DESC
  state_ASC
  state_DESC
  zip_ASC
  zip_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type AddressPreviousValues {
  id: ID!
  hash: String!
  name: String!
  line1: String!
  line2: String
  city: String!
  state: String!
  zip: String!
  createdAt: DateTime!
  updatedAt: DateTime!
}

type AddressSubscriptionPayload {
  mutation: MutationType!
  node: Address
  updatedFields: [String!]
  previousValues: AddressPreviousValues
}

input AddressSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: AddressWhereInput
  AND: [AddressSubscriptionWhereInput!]
  OR: [AddressSubscriptionWhereInput!]
  NOT: [AddressSubscriptionWhereInput!]
}

input AddressUpdateDataInput {
  hash: String
  name: String
  line1: String
  line2: String
  city: String
  state: String
  zip: String
}

input AddressUpdateInput {
  hash: String
  name: String
  line1: String
  line2: String
  city: String
  state: String
  zip: String
}

input AddressUpdateManyMutationInput {
  hash: String
  name: String
  line1: String
  line2: String
  city: String
  state: String
  zip: String
}

input AddressUpdateOneRequiredInput {
  create: AddressCreateInput
  update: AddressUpdateDataInput
  upsert: AddressUpsertNestedInput
  connect: AddressWhereUniqueInput
}

input AddressUpsertNestedInput {
  update: AddressUpdateDataInput!
  create: AddressCreateInput!
}

input AddressWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  hash: String
  hash_not: String
  hash_in: [String!]
  hash_not_in: [String!]
  hash_lt: String
  hash_lte: String
  hash_gt: String
  hash_gte: String
  hash_contains: String
  hash_not_contains: String
  hash_starts_with: String
  hash_not_starts_with: String
  hash_ends_with: String
  hash_not_ends_with: String
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  line1: String
  line1_not: String
  line1_in: [String!]
  line1_not_in: [String!]
  line1_lt: String
  line1_lte: String
  line1_gt: String
  line1_gte: String
  line1_contains: String
  line1_not_contains: String
  line1_starts_with: String
  line1_not_starts_with: String
  line1_ends_with: String
  line1_not_ends_with: String
  line2: String
  line2_not: String
  line2_in: [String!]
  line2_not_in: [String!]
  line2_lt: String
  line2_lte: String
  line2_gt: String
  line2_gte: String
  line2_contains: String
  line2_not_contains: String
  line2_starts_with: String
  line2_not_starts_with: String
  line2_ends_with: String
  line2_not_ends_with: String
  city: String
  city_not: String
  city_in: [String!]
  city_not_in: [String!]
  city_lt: String
  city_lte: String
  city_gt: String
  city_gte: String
  city_contains: String
  city_not_contains: String
  city_starts_with: String
  city_not_starts_with: String
  city_ends_with: String
  city_not_ends_with: String
  state: String
  state_not: String
  state_in: [String!]
  state_not_in: [String!]
  state_lt: String
  state_lte: String
  state_gt: String
  state_gte: String
  state_contains: String
  state_not_contains: String
  state_starts_with: String
  state_not_starts_with: String
  state_ends_with: String
  state_not_ends_with: String
  zip: String
  zip_not: String
  zip_in: [String!]
  zip_not_in: [String!]
  zip_lt: String
  zip_lte: String
  zip_gt: String
  zip_gte: String
  zip_contains: String
  zip_not_contains: String
  zip_starts_with: String
  zip_not_starts_with: String
  zip_ends_with: String
  zip_not_ends_with: String
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [AddressWhereInput!]
  OR: [AddressWhereInput!]
  NOT: [AddressWhereInput!]
}

input AddressWhereUniqueInput {
  id: ID
  hash: String
}

type AggregateAddress {
  count: Int!
}

type AggregateLetter {
  count: Int!
}

type AggregateMail {
  count: Int!
}

type AggregatePayment {
  count: Int!
}

type AggregateTemplate {
  count: Int!
}

type AggregateUser {
  count: Int!
}

type BatchPayload {
  count: Long!
}

scalar DateTime

scalar Json

type Letter {
  id: ID!
  fromAddress: Address!
  toAddress: Address!
  content: Json!
  payment: Payment
  mail: Mail
  user: User
  template: Template
  createdAt: DateTime!
  updatedAt: DateTime!
}

type LetterConnection {
  pageInfo: PageInfo!
  edges: [LetterEdge]!
  aggregate: AggregateLetter!
}

input LetterCreateInput {
  id: ID
  fromAddress: AddressCreateOneInput!
  toAddress: AddressCreateOneInput!
  content: Json!
  payment: PaymentCreateOneWithoutLetterInput
  mail: MailCreateOneWithoutLetterInput
  user: UserCreateOneWithoutLettersInput
  template: TemplateCreateOneInput
}

input LetterCreateManyWithoutUserInput {
  create: [LetterCreateWithoutUserInput!]
  connect: [LetterWhereUniqueInput!]
}

input LetterCreateOneWithoutMailInput {
  create: LetterCreateWithoutMailInput
  connect: LetterWhereUniqueInput
}

input LetterCreateOneWithoutPaymentInput {
  create: LetterCreateWithoutPaymentInput
  connect: LetterWhereUniqueInput
}

input LetterCreateWithoutMailInput {
  id: ID
  fromAddress: AddressCreateOneInput!
  toAddress: AddressCreateOneInput!
  content: Json!
  payment: PaymentCreateOneWithoutLetterInput
  user: UserCreateOneWithoutLettersInput
  template: TemplateCreateOneInput
}

input LetterCreateWithoutPaymentInput {
  id: ID
  fromAddress: AddressCreateOneInput!
  toAddress: AddressCreateOneInput!
  content: Json!
  mail: MailCreateOneWithoutLetterInput
  user: UserCreateOneWithoutLettersInput
  template: TemplateCreateOneInput
}

input LetterCreateWithoutUserInput {
  id: ID
  fromAddress: AddressCreateOneInput!
  toAddress: AddressCreateOneInput!
  content: Json!
  payment: PaymentCreateOneWithoutLetterInput
  mail: MailCreateOneWithoutLetterInput
  template: TemplateCreateOneInput
}

type LetterEdge {
  node: Letter!
  cursor: String!
}

enum LetterOrderByInput {
  id_ASC
  id_DESC
  content_ASC
  content_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type LetterPreviousValues {
  id: ID!
  content: Json!
  createdAt: DateTime!
  updatedAt: DateTime!
}

input LetterScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [LetterScalarWhereInput!]
  OR: [LetterScalarWhereInput!]
  NOT: [LetterScalarWhereInput!]
}

type LetterSubscriptionPayload {
  mutation: MutationType!
  node: Letter
  updatedFields: [String!]
  previousValues: LetterPreviousValues
}

input LetterSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: LetterWhereInput
  AND: [LetterSubscriptionWhereInput!]
  OR: [LetterSubscriptionWhereInput!]
  NOT: [LetterSubscriptionWhereInput!]
}

input LetterUpdateInput {
  fromAddress: AddressUpdateOneRequiredInput
  toAddress: AddressUpdateOneRequiredInput
  content: Json
  payment: PaymentUpdateOneWithoutLetterInput
  mail: MailUpdateOneWithoutLetterInput
  user: UserUpdateOneWithoutLettersInput
  template: TemplateUpdateOneInput
}

input LetterUpdateManyDataInput {
  content: Json
}

input LetterUpdateManyMutationInput {
  content: Json
}

input LetterUpdateManyWithoutUserInput {
  create: [LetterCreateWithoutUserInput!]
  delete: [LetterWhereUniqueInput!]
  connect: [LetterWhereUniqueInput!]
  set: [LetterWhereUniqueInput!]
  disconnect: [LetterWhereUniqueInput!]
  update: [LetterUpdateWithWhereUniqueWithoutUserInput!]
  upsert: [LetterUpsertWithWhereUniqueWithoutUserInput!]
  deleteMany: [LetterScalarWhereInput!]
  updateMany: [LetterUpdateManyWithWhereNestedInput!]
}

input LetterUpdateManyWithWhereNestedInput {
  where: LetterScalarWhereInput!
  data: LetterUpdateManyDataInput!
}

input LetterUpdateOneRequiredWithoutMailInput {
  create: LetterCreateWithoutMailInput
  update: LetterUpdateWithoutMailDataInput
  upsert: LetterUpsertWithoutMailInput
  connect: LetterWhereUniqueInput
}

input LetterUpdateOneRequiredWithoutPaymentInput {
  create: LetterCreateWithoutPaymentInput
  update: LetterUpdateWithoutPaymentDataInput
  upsert: LetterUpsertWithoutPaymentInput
  connect: LetterWhereUniqueInput
}

input LetterUpdateWithoutMailDataInput {
  fromAddress: AddressUpdateOneRequiredInput
  toAddress: AddressUpdateOneRequiredInput
  content: Json
  payment: PaymentUpdateOneWithoutLetterInput
  user: UserUpdateOneWithoutLettersInput
  template: TemplateUpdateOneInput
}

input LetterUpdateWithoutPaymentDataInput {
  fromAddress: AddressUpdateOneRequiredInput
  toAddress: AddressUpdateOneRequiredInput
  content: Json
  mail: MailUpdateOneWithoutLetterInput
  user: UserUpdateOneWithoutLettersInput
  template: TemplateUpdateOneInput
}

input LetterUpdateWithoutUserDataInput {
  fromAddress: AddressUpdateOneRequiredInput
  toAddress: AddressUpdateOneRequiredInput
  content: Json
  payment: PaymentUpdateOneWithoutLetterInput
  mail: MailUpdateOneWithoutLetterInput
  template: TemplateUpdateOneInput
}

input LetterUpdateWithWhereUniqueWithoutUserInput {
  where: LetterWhereUniqueInput!
  data: LetterUpdateWithoutUserDataInput!
}

input LetterUpsertWithoutMailInput {
  update: LetterUpdateWithoutMailDataInput!
  create: LetterCreateWithoutMailInput!
}

input LetterUpsertWithoutPaymentInput {
  update: LetterUpdateWithoutPaymentDataInput!
  create: LetterCreateWithoutPaymentInput!
}

input LetterUpsertWithWhereUniqueWithoutUserInput {
  where: LetterWhereUniqueInput!
  update: LetterUpdateWithoutUserDataInput!
  create: LetterCreateWithoutUserInput!
}

input LetterWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  fromAddress: AddressWhereInput
  toAddress: AddressWhereInput
  payment: PaymentWhereInput
  mail: MailWhereInput
  user: UserWhereInput
  template: TemplateWhereInput
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [LetterWhereInput!]
  OR: [LetterWhereInput!]
  NOT: [LetterWhereInput!]
}

input LetterWhereUniqueInput {
  id: ID
}

scalar Long

type Mail {
  id: ID!
  lobId: String!
  letter: Letter!
  expectedDeliveryDate: DateTime!
  createdAt: DateTime!
  updatedAt: DateTime!
}

type MailConnection {
  pageInfo: PageInfo!
  edges: [MailEdge]!
  aggregate: AggregateMail!
}

input MailCreateInput {
  id: ID
  lobId: String!
  letter: LetterCreateOneWithoutMailInput!
  expectedDeliveryDate: DateTime!
}

input MailCreateOneWithoutLetterInput {
  create: MailCreateWithoutLetterInput
  connect: MailWhereUniqueInput
}

input MailCreateWithoutLetterInput {
  id: ID
  lobId: String!
  expectedDeliveryDate: DateTime!
}

type MailEdge {
  node: Mail!
  cursor: String!
}

enum MailOrderByInput {
  id_ASC
  id_DESC
  lobId_ASC
  lobId_DESC
  expectedDeliveryDate_ASC
  expectedDeliveryDate_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type MailPreviousValues {
  id: ID!
  lobId: String!
  expectedDeliveryDate: DateTime!
  createdAt: DateTime!
  updatedAt: DateTime!
}

type MailSubscriptionPayload {
  mutation: MutationType!
  node: Mail
  updatedFields: [String!]
  previousValues: MailPreviousValues
}

input MailSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: MailWhereInput
  AND: [MailSubscriptionWhereInput!]
  OR: [MailSubscriptionWhereInput!]
  NOT: [MailSubscriptionWhereInput!]
}

input MailUpdateInput {
  lobId: String
  letter: LetterUpdateOneRequiredWithoutMailInput
  expectedDeliveryDate: DateTime
}

input MailUpdateManyMutationInput {
  lobId: String
  expectedDeliveryDate: DateTime
}

input MailUpdateOneWithoutLetterInput {
  create: MailCreateWithoutLetterInput
  update: MailUpdateWithoutLetterDataInput
  upsert: MailUpsertWithoutLetterInput
  delete: Boolean
  disconnect: Boolean
  connect: MailWhereUniqueInput
}

input MailUpdateWithoutLetterDataInput {
  lobId: String
  expectedDeliveryDate: DateTime
}

input MailUpsertWithoutLetterInput {
  update: MailUpdateWithoutLetterDataInput!
  create: MailCreateWithoutLetterInput!
}

input MailWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  lobId: String
  lobId_not: String
  lobId_in: [String!]
  lobId_not_in: [String!]
  lobId_lt: String
  lobId_lte: String
  lobId_gt: String
  lobId_gte: String
  lobId_contains: String
  lobId_not_contains: String
  lobId_starts_with: String
  lobId_not_starts_with: String
  lobId_ends_with: String
  lobId_not_ends_with: String
  letter: LetterWhereInput
  expectedDeliveryDate: DateTime
  expectedDeliveryDate_not: DateTime
  expectedDeliveryDate_in: [DateTime!]
  expectedDeliveryDate_not_in: [DateTime!]
  expectedDeliveryDate_lt: DateTime
  expectedDeliveryDate_lte: DateTime
  expectedDeliveryDate_gt: DateTime
  expectedDeliveryDate_gte: DateTime
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [MailWhereInput!]
  OR: [MailWhereInput!]
  NOT: [MailWhereInput!]
}

input MailWhereUniqueInput {
  id: ID
}

type Mutation {
  createAddress(data: AddressCreateInput!): Address!
  updateAddress(data: AddressUpdateInput!, where: AddressWhereUniqueInput!): Address
  updateManyAddresses(data: AddressUpdateManyMutationInput!, where: AddressWhereInput): BatchPayload!
  upsertAddress(where: AddressWhereUniqueInput!, create: AddressCreateInput!, update: AddressUpdateInput!): Address!
  deleteAddress(where: AddressWhereUniqueInput!): Address
  deleteManyAddresses(where: AddressWhereInput): BatchPayload!
  createLetter(data: LetterCreateInput!): Letter!
  updateLetter(data: LetterUpdateInput!, where: LetterWhereUniqueInput!): Letter
  updateManyLetters(data: LetterUpdateManyMutationInput!, where: LetterWhereInput): BatchPayload!
  upsertLetter(where: LetterWhereUniqueInput!, create: LetterCreateInput!, update: LetterUpdateInput!): Letter!
  deleteLetter(where: LetterWhereUniqueInput!): Letter
  deleteManyLetters(where: LetterWhereInput): BatchPayload!
  createMail(data: MailCreateInput!): Mail!
  updateMail(data: MailUpdateInput!, where: MailWhereUniqueInput!): Mail
  updateManyMails(data: MailUpdateManyMutationInput!, where: MailWhereInput): BatchPayload!
  upsertMail(where: MailWhereUniqueInput!, create: MailCreateInput!, update: MailUpdateInput!): Mail!
  deleteMail(where: MailWhereUniqueInput!): Mail
  deleteManyMails(where: MailWhereInput): BatchPayload!
  createPayment(data: PaymentCreateInput!): Payment!
  updatePayment(data: PaymentUpdateInput!, where: PaymentWhereUniqueInput!): Payment
  updateManyPayments(data: PaymentUpdateManyMutationInput!, where: PaymentWhereInput): BatchPayload!
  upsertPayment(where: PaymentWhereUniqueInput!, create: PaymentCreateInput!, update: PaymentUpdateInput!): Payment!
  deletePayment(where: PaymentWhereUniqueInput!): Payment
  deleteManyPayments(where: PaymentWhereInput): BatchPayload!
  createTemplate(data: TemplateCreateInput!): Template!
  updateTemplate(data: TemplateUpdateInput!, where: TemplateWhereUniqueInput!): Template
  updateManyTemplates(data: TemplateUpdateManyMutationInput!, where: TemplateWhereInput): BatchPayload!
  upsertTemplate(where: TemplateWhereUniqueInput!, create: TemplateCreateInput!, update: TemplateUpdateInput!): Template!
  deleteTemplate(where: TemplateWhereUniqueInput!): Template
  deleteManyTemplates(where: TemplateWhereInput): BatchPayload!
  createUser(data: UserCreateInput!): User!
  updateUser(data: UserUpdateInput!, where: UserWhereUniqueInput!): User
  updateManyUsers(data: UserUpdateManyMutationInput!, where: UserWhereInput): BatchPayload!
  upsertUser(where: UserWhereUniqueInput!, create: UserCreateInput!, update: UserUpdateInput!): User!
  deleteUser(where: UserWhereUniqueInput!): User
  deleteManyUsers(where: UserWhereInput): BatchPayload!
}

enum MutationType {
  CREATED
  UPDATED
  DELETED
}

interface Node {
  id: ID!
}

type PageInfo {
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  startCursor: String
  endCursor: String
}

type Payment {
  id: ID!
  stripeId: String!
  letter: Letter!
  createdAt: DateTime!
  updatedAt: DateTime!
}

type PaymentConnection {
  pageInfo: PageInfo!
  edges: [PaymentEdge]!
  aggregate: AggregatePayment!
}

input PaymentCreateInput {
  id: ID
  stripeId: String!
  letter: LetterCreateOneWithoutPaymentInput!
}

input PaymentCreateOneWithoutLetterInput {
  create: PaymentCreateWithoutLetterInput
  connect: PaymentWhereUniqueInput
}

input PaymentCreateWithoutLetterInput {
  id: ID
  stripeId: String!
}

type PaymentEdge {
  node: Payment!
  cursor: String!
}

enum PaymentOrderByInput {
  id_ASC
  id_DESC
  stripeId_ASC
  stripeId_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type PaymentPreviousValues {
  id: ID!
  stripeId: String!
  createdAt: DateTime!
  updatedAt: DateTime!
}

type PaymentSubscriptionPayload {
  mutation: MutationType!
  node: Payment
  updatedFields: [String!]
  previousValues: PaymentPreviousValues
}

input PaymentSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: PaymentWhereInput
  AND: [PaymentSubscriptionWhereInput!]
  OR: [PaymentSubscriptionWhereInput!]
  NOT: [PaymentSubscriptionWhereInput!]
}

input PaymentUpdateInput {
  stripeId: String
  letter: LetterUpdateOneRequiredWithoutPaymentInput
}

input PaymentUpdateManyMutationInput {
  stripeId: String
}

input PaymentUpdateOneWithoutLetterInput {
  create: PaymentCreateWithoutLetterInput
  update: PaymentUpdateWithoutLetterDataInput
  upsert: PaymentUpsertWithoutLetterInput
  delete: Boolean
  disconnect: Boolean
  connect: PaymentWhereUniqueInput
}

input PaymentUpdateWithoutLetterDataInput {
  stripeId: String
}

input PaymentUpsertWithoutLetterInput {
  update: PaymentUpdateWithoutLetterDataInput!
  create: PaymentCreateWithoutLetterInput!
}

input PaymentWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  stripeId: String
  stripeId_not: String
  stripeId_in: [String!]
  stripeId_not_in: [String!]
  stripeId_lt: String
  stripeId_lte: String
  stripeId_gt: String
  stripeId_gte: String
  stripeId_contains: String
  stripeId_not_contains: String
  stripeId_starts_with: String
  stripeId_not_starts_with: String
  stripeId_ends_with: String
  stripeId_not_ends_with: String
  letter: LetterWhereInput
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [PaymentWhereInput!]
  OR: [PaymentWhereInput!]
  NOT: [PaymentWhereInput!]
}

input PaymentWhereUniqueInput {
  id: ID
}

type Query {
  address(where: AddressWhereUniqueInput!): Address
  addresses(where: AddressWhereInput, orderBy: AddressOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Address]!
  addressesConnection(where: AddressWhereInput, orderBy: AddressOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): AddressConnection!
  letter(where: LetterWhereUniqueInput!): Letter
  letters(where: LetterWhereInput, orderBy: LetterOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Letter]!
  lettersConnection(where: LetterWhereInput, orderBy: LetterOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): LetterConnection!
  mail(where: MailWhereUniqueInput!): Mail
  mails(where: MailWhereInput, orderBy: MailOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Mail]!
  mailsConnection(where: MailWhereInput, orderBy: MailOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): MailConnection!
  payment(where: PaymentWhereUniqueInput!): Payment
  payments(where: PaymentWhereInput, orderBy: PaymentOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Payment]!
  paymentsConnection(where: PaymentWhereInput, orderBy: PaymentOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): PaymentConnection!
  template(where: TemplateWhereUniqueInput!): Template
  templates(where: TemplateWhereInput, orderBy: TemplateOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Template]!
  templatesConnection(where: TemplateWhereInput, orderBy: TemplateOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): TemplateConnection!
  user(where: UserWhereUniqueInput!): User
  users(where: UserWhereInput, orderBy: UserOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [User]!
  usersConnection(where: UserWhereInput, orderBy: UserOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): UserConnection!
  node(id: ID!): Node
}

type Subscription {
  address(where: AddressSubscriptionWhereInput): AddressSubscriptionPayload
  letter(where: LetterSubscriptionWhereInput): LetterSubscriptionPayload
  mail(where: MailSubscriptionWhereInput): MailSubscriptionPayload
  payment(where: PaymentSubscriptionWhereInput): PaymentSubscriptionPayload
  template(where: TemplateSubscriptionWhereInput): TemplateSubscriptionPayload
  user(where: UserSubscriptionWhereInput): UserSubscriptionPayload
}

type Template {
  id: ID!
  title: String!
  tags: String!
  content: Json!
  user: User!
  createdAt: DateTime!
  updatedAt: DateTime!
}

type TemplateConnection {
  pageInfo: PageInfo!
  edges: [TemplateEdge]!
  aggregate: AggregateTemplate!
}

input TemplateCreateInput {
  id: ID
  title: String!
  tags: String!
  content: Json!
  user: UserCreateOneWithoutTemplatesInput!
}

input TemplateCreateManyWithoutUserInput {
  create: [TemplateCreateWithoutUserInput!]
  connect: [TemplateWhereUniqueInput!]
}

input TemplateCreateOneInput {
  create: TemplateCreateInput
  connect: TemplateWhereUniqueInput
}

input TemplateCreateWithoutUserInput {
  id: ID
  title: String!
  tags: String!
  content: Json!
}

type TemplateEdge {
  node: Template!
  cursor: String!
}

enum TemplateOrderByInput {
  id_ASC
  id_DESC
  title_ASC
  title_DESC
  tags_ASC
  tags_DESC
  content_ASC
  content_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type TemplatePreviousValues {
  id: ID!
  title: String!
  tags: String!
  content: Json!
  createdAt: DateTime!
  updatedAt: DateTime!
}

input TemplateScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  title: String
  title_not: String
  title_in: [String!]
  title_not_in: [String!]
  title_lt: String
  title_lte: String
  title_gt: String
  title_gte: String
  title_contains: String
  title_not_contains: String
  title_starts_with: String
  title_not_starts_with: String
  title_ends_with: String
  title_not_ends_with: String
  tags: String
  tags_not: String
  tags_in: [String!]
  tags_not_in: [String!]
  tags_lt: String
  tags_lte: String
  tags_gt: String
  tags_gte: String
  tags_contains: String
  tags_not_contains: String
  tags_starts_with: String
  tags_not_starts_with: String
  tags_ends_with: String
  tags_not_ends_with: String
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [TemplateScalarWhereInput!]
  OR: [TemplateScalarWhereInput!]
  NOT: [TemplateScalarWhereInput!]
}

type TemplateSubscriptionPayload {
  mutation: MutationType!
  node: Template
  updatedFields: [String!]
  previousValues: TemplatePreviousValues
}

input TemplateSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: TemplateWhereInput
  AND: [TemplateSubscriptionWhereInput!]
  OR: [TemplateSubscriptionWhereInput!]
  NOT: [TemplateSubscriptionWhereInput!]
}

input TemplateUpdateDataInput {
  title: String
  tags: String
  content: Json
  user: UserUpdateOneRequiredWithoutTemplatesInput
}

input TemplateUpdateInput {
  title: String
  tags: String
  content: Json
  user: UserUpdateOneRequiredWithoutTemplatesInput
}

input TemplateUpdateManyDataInput {
  title: String
  tags: String
  content: Json
}

input TemplateUpdateManyMutationInput {
  title: String
  tags: String
  content: Json
}

input TemplateUpdateManyWithoutUserInput {
  create: [TemplateCreateWithoutUserInput!]
  delete: [TemplateWhereUniqueInput!]
  connect: [TemplateWhereUniqueInput!]
  set: [TemplateWhereUniqueInput!]
  disconnect: [TemplateWhereUniqueInput!]
  update: [TemplateUpdateWithWhereUniqueWithoutUserInput!]
  upsert: [TemplateUpsertWithWhereUniqueWithoutUserInput!]
  deleteMany: [TemplateScalarWhereInput!]
  updateMany: [TemplateUpdateManyWithWhereNestedInput!]
}

input TemplateUpdateManyWithWhereNestedInput {
  where: TemplateScalarWhereInput!
  data: TemplateUpdateManyDataInput!
}

input TemplateUpdateOneInput {
  create: TemplateCreateInput
  update: TemplateUpdateDataInput
  upsert: TemplateUpsertNestedInput
  delete: Boolean
  disconnect: Boolean
  connect: TemplateWhereUniqueInput
}

input TemplateUpdateWithoutUserDataInput {
  title: String
  tags: String
  content: Json
}

input TemplateUpdateWithWhereUniqueWithoutUserInput {
  where: TemplateWhereUniqueInput!
  data: TemplateUpdateWithoutUserDataInput!
}

input TemplateUpsertNestedInput {
  update: TemplateUpdateDataInput!
  create: TemplateCreateInput!
}

input TemplateUpsertWithWhereUniqueWithoutUserInput {
  where: TemplateWhereUniqueInput!
  update: TemplateUpdateWithoutUserDataInput!
  create: TemplateCreateWithoutUserInput!
}

input TemplateWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  title: String
  title_not: String
  title_in: [String!]
  title_not_in: [String!]
  title_lt: String
  title_lte: String
  title_gt: String
  title_gte: String
  title_contains: String
  title_not_contains: String
  title_starts_with: String
  title_not_starts_with: String
  title_ends_with: String
  title_not_ends_with: String
  tags: String
  tags_not: String
  tags_in: [String!]
  tags_not_in: [String!]
  tags_lt: String
  tags_lte: String
  tags_gt: String
  tags_gte: String
  tags_contains: String
  tags_not_contains: String
  tags_starts_with: String
  tags_not_starts_with: String
  tags_ends_with: String
  tags_not_ends_with: String
  user: UserWhereInput
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [TemplateWhereInput!]
  OR: [TemplateWhereInput!]
  NOT: [TemplateWhereInput!]
}

input TemplateWhereUniqueInput {
  id: ID
}

type User {
  id: ID!
  email: String!
  password: String!
  resetToken: String
  resetExpiry: Float
  letters(where: LetterWhereInput, orderBy: LetterOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Letter!]
  templates(where: TemplateWhereInput, orderBy: TemplateOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Template!]
  createdAt: DateTime!
  updatedAt: DateTime!
}

type UserConnection {
  pageInfo: PageInfo!
  edges: [UserEdge]!
  aggregate: AggregateUser!
}

input UserCreateInput {
  id: ID
  email: String!
  password: String!
  resetToken: String
  resetExpiry: Float
  letters: LetterCreateManyWithoutUserInput
  templates: TemplateCreateManyWithoutUserInput
}

input UserCreateOneWithoutLettersInput {
  create: UserCreateWithoutLettersInput
  connect: UserWhereUniqueInput
}

input UserCreateOneWithoutTemplatesInput {
  create: UserCreateWithoutTemplatesInput
  connect: UserWhereUniqueInput
}

input UserCreateWithoutLettersInput {
  id: ID
  email: String!
  password: String!
  resetToken: String
  resetExpiry: Float
  templates: TemplateCreateManyWithoutUserInput
}

input UserCreateWithoutTemplatesInput {
  id: ID
  email: String!
  password: String!
  resetToken: String
  resetExpiry: Float
  letters: LetterCreateManyWithoutUserInput
}

type UserEdge {
  node: User!
  cursor: String!
}

enum UserOrderByInput {
  id_ASC
  id_DESC
  email_ASC
  email_DESC
  password_ASC
  password_DESC
  resetToken_ASC
  resetToken_DESC
  resetExpiry_ASC
  resetExpiry_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type UserPreviousValues {
  id: ID!
  email: String!
  password: String!
  resetToken: String
  resetExpiry: Float
  createdAt: DateTime!
  updatedAt: DateTime!
}

type UserSubscriptionPayload {
  mutation: MutationType!
  node: User
  updatedFields: [String!]
  previousValues: UserPreviousValues
}

input UserSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: UserWhereInput
  AND: [UserSubscriptionWhereInput!]
  OR: [UserSubscriptionWhereInput!]
  NOT: [UserSubscriptionWhereInput!]
}

input UserUpdateInput {
  email: String
  password: String
  resetToken: String
  resetExpiry: Float
  letters: LetterUpdateManyWithoutUserInput
  templates: TemplateUpdateManyWithoutUserInput
}

input UserUpdateManyMutationInput {
  email: String
  password: String
  resetToken: String
  resetExpiry: Float
}

input UserUpdateOneRequiredWithoutTemplatesInput {
  create: UserCreateWithoutTemplatesInput
  update: UserUpdateWithoutTemplatesDataInput
  upsert: UserUpsertWithoutTemplatesInput
  connect: UserWhereUniqueInput
}

input UserUpdateOneWithoutLettersInput {
  create: UserCreateWithoutLettersInput
  update: UserUpdateWithoutLettersDataInput
  upsert: UserUpsertWithoutLettersInput
  delete: Boolean
  disconnect: Boolean
  connect: UserWhereUniqueInput
}

input UserUpdateWithoutLettersDataInput {
  email: String
  password: String
  resetToken: String
  resetExpiry: Float
  templates: TemplateUpdateManyWithoutUserInput
}

input UserUpdateWithoutTemplatesDataInput {
  email: String
  password: String
  resetToken: String
  resetExpiry: Float
  letters: LetterUpdateManyWithoutUserInput
}

input UserUpsertWithoutLettersInput {
  update: UserUpdateWithoutLettersDataInput!
  create: UserCreateWithoutLettersInput!
}

input UserUpsertWithoutTemplatesInput {
  update: UserUpdateWithoutTemplatesDataInput!
  create: UserCreateWithoutTemplatesInput!
}

input UserWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  email: String
  email_not: String
  email_in: [String!]
  email_not_in: [String!]
  email_lt: String
  email_lte: String
  email_gt: String
  email_gte: String
  email_contains: String
  email_not_contains: String
  email_starts_with: String
  email_not_starts_with: String
  email_ends_with: String
  email_not_ends_with: String
  password: String
  password_not: String
  password_in: [String!]
  password_not_in: [String!]
  password_lt: String
  password_lte: String
  password_gt: String
  password_gte: String
  password_contains: String
  password_not_contains: String
  password_starts_with: String
  password_not_starts_with: String
  password_ends_with: String
  password_not_ends_with: String
  resetToken: String
  resetToken_not: String
  resetToken_in: [String!]
  resetToken_not_in: [String!]
  resetToken_lt: String
  resetToken_lte: String
  resetToken_gt: String
  resetToken_gte: String
  resetToken_contains: String
  resetToken_not_contains: String
  resetToken_starts_with: String
  resetToken_not_starts_with: String
  resetToken_ends_with: String
  resetToken_not_ends_with: String
  resetExpiry: Float
  resetExpiry_not: Float
  resetExpiry_in: [Float!]
  resetExpiry_not_in: [Float!]
  resetExpiry_lt: Float
  resetExpiry_lte: Float
  resetExpiry_gt: Float
  resetExpiry_gte: Float
  letters_every: LetterWhereInput
  letters_some: LetterWhereInput
  letters_none: LetterWhereInput
  templates_every: TemplateWhereInput
  templates_some: TemplateWhereInput
  templates_none: TemplateWhereInput
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [UserWhereInput!]
  OR: [UserWhereInput!]
  NOT: [UserWhereInput!]
}

input UserWhereUniqueInput {
  id: ID
  email: String
}
`